#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 32
    bytecblock "organizer" "proceeds" "asset_id" 0x151f7c75 "unit_price" "sale_start" "sale_end" "per_cap" "purchased"
    // smart_contracts/ticketing_app/contract.py:5
    // class TicketingApp(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@11
    pushbytess 0x1658db52 0xb7355fd1 0xbe0df53c 0x00cfce65 0x02bece11 // method "buy(uint64,address)uint64", method "withdraw()void", method "get_sale_info()(uint64,uint64,uint64,uint64,address,uint64,uint64)", method "get_purchased(address)uint64", method "hello(string)string"
    txna ApplicationArgs 0
    match buy withdraw get_sale_info get_purchased hello
    err

main_create_NoOp@11:
    // smart_contracts/ticketing_app/contract.py:5
    // class TicketingApp(ARC4Contract):
    pushbytes 0x78656093 // method "bootstrap(uint64,uint64,uint64,uint64,uint64,address)void"
    txna ApplicationArgs 0
    match bootstrap
    err


// smart_contracts.ticketing_app.contract.TicketingApp.bootstrap[routing]() -> void:
bootstrap:
    // smart_contracts/ticketing_app/contract.py:21
    // @abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 6
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/ticketing_app/contract.py:30
    // assert self.asset_id.value == 0, "already bootstrapped"
    intc_0 // 0
    bytec_2 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    !
    assert // already bootstrapped
    // smart_contracts/ticketing_app/contract.py:31
    // self.asset_id.value = asset_id
    bytec_2 // "asset_id"
    uncover 6
    app_global_put
    // smart_contracts/ticketing_app/contract.py:32
    // self.unit_price.value = price
    bytec 4 // "unit_price"
    uncover 5
    app_global_put
    // smart_contracts/ticketing_app/contract.py:33
    // self.sale_start.value = start
    bytec 5 // "sale_start"
    uncover 4
    app_global_put
    // smart_contracts/ticketing_app/contract.py:34
    // self.sale_end.value = end
    bytec 6 // "sale_end"
    uncover 3
    app_global_put
    // smart_contracts/ticketing_app/contract.py:35
    // self.per_cap.value = per_wallet_cap
    bytec 7 // "per_cap"
    uncover 2
    app_global_put
    // smart_contracts/ticketing_app/contract.py:36
    // self.organizer.value = organizer
    bytec_0 // "organizer"
    swap
    app_global_put
    // smart_contracts/ticketing_app/contract.py:21
    // @abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.ticketing_app.contract.TicketingApp.buy[routing]() -> void:
buy:
    // smart_contracts/ticketing_app/contract.py:38
    // @abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/ticketing_app/contract.py:41-42
    // # time + window checks
    // now = Global.latest_timestamp
    global LatestTimestamp
    dup
    // smart_contracts/ticketing_app/contract.py:43
    // assert now >= self.sale_start.value and now <= self.sale_end.value, "sale closed"
    intc_0 // 0
    bytec 5 // "sale_start"
    app_global_get_ex
    assert // check self.sale_start exists
    >=
    bz buy_bool_false@4
    intc_0 // 0
    bytec 6 // "sale_end"
    app_global_get_ex
    assert // check self.sale_end exists
    dig 1
    >=
    bz buy_bool_false@4
    intc_1 // 1

buy_bool_merge@5:
    // smart_contracts/ticketing_app/contract.py:43
    // assert now >= self.sale_start.value and now <= self.sale_end.value, "sale closed"
    assert // sale closed
    // smart_contracts/ticketing_app/contract.py:44
    // assert qty > 0, "qty"
    dig 2
    dup
    assert // qty
    // smart_contracts/ticketing_app/contract.py:49-50
    // # enforce per-wallet cap
    // assert self.purchased[buyer] + qty <= self.per_cap.value, "cap"
    dig 2
    dup
    cover 2
    intc_0 // 0
    bytec 8 // "purchased"
    app_local_get_ex
    assert // check self.purchased exists for account
    dig 1
    +
    intc_0 // 0
    bytec 7 // "per_cap"
    app_global_get_ex
    assert // check self.per_cap exists
    dig 1
    >=
    assert // cap
    // smart_contracts/ticketing_app/contract.py:52-53
    // # increment per-buyer count and track proceeds
    // self.purchased[buyer] += qty
    dig 2
    bytec 8 // "purchased"
    uncover 2
    app_local_put
    // smart_contracts/ticketing_app/contract.py:54
    // self.proceeds.value += qty * self.unit_price.value
    intc_0 // 0
    bytec_1 // "proceeds"
    app_global_get_ex
    assert // check self.proceeds exists
    intc_0 // 0
    bytec 4 // "unit_price"
    app_global_get_ex
    assert // check self.unit_price exists
    dig 2
    *
    +
    bytec_1 // "proceeds"
    swap
    app_global_put
    // smart_contracts/ticketing_app/contract.py:56-63
    // # Transfer ASA from organizer's holding to buyer via clawback
    // # Requires: ASA.clawback = this app address, organizer holds inventory
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id.value,
    //     asset_sender=self.organizer.value,   # take from organizer (clawback)
    //     asset_receiver=buyer,
    //     asset_amount=qty
    // ).submit()
    itxn_begin
    // smart_contracts/ticketing_app/contract.py:59
    // xfer_asset=self.asset_id.value,
    intc_0 // 0
    bytec_2 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/ticketing_app/contract.py:60
    // asset_sender=self.organizer.value,   # take from organizer (clawback)
    intc_0 // 0
    bytec_0 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field AssetSender
    itxn_field XferAsset
    // smart_contracts/ticketing_app/contract.py:56-58
    // # Transfer ASA from organizer's holding to buyer via clawback
    // # Requires: ASA.clawback = this app address, organizer holds inventory
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/ticketing_app/contract.py:56-63
    // # Transfer ASA from organizer's holding to buyer via clawback
    // # Requires: ASA.clawback = this app address, organizer holds inventory
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id.value,
    //     asset_sender=self.organizer.value,   # take from organizer (clawback)
    //     asset_receiver=buyer,
    //     asset_amount=qty
    // ).submit()
    itxn_submit
    // smart_contracts/ticketing_app/contract.py:38
    // @abimethod
    bytec_3 // 0x151f7c75
    dig 4
    concat
    log
    intc_1 // 1
    return

buy_bool_false@4:
    intc_0 // 0
    b buy_bool_merge@5


// smart_contracts.ticketing_app.contract.TicketingApp.withdraw[routing]() -> void:
withdraw:
    // smart_contracts/ticketing_app/contract.py:71
    // assert Txn.sender == self.organizer.value, "only organizer"
    txn Sender
    intc_0 // 0
    bytec_0 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    ==
    assert // only organizer
    // smart_contracts/ticketing_app/contract.py:72
    // amt = self.proceeds.value
    intc_0 // 0
    bytec_1 // "proceeds"
    app_global_get_ex
    assert // check self.proceeds exists
    // smart_contracts/ticketing_app/contract.py:73
    // assert amt > 0, "nothing to withdraw"
    dup
    assert // nothing to withdraw
    // smart_contracts/ticketing_app/contract.py:75
    // self.proceeds.value = UInt64(0)
    bytec_1 // "proceeds"
    intc_0 // 0
    app_global_put
    // smart_contracts/ticketing_app/contract.py:77-81
    // # Pay out ALGO to organizer
    // itxn.Payment(
    //     receiver=self.organizer.value,
    //     amount=amt
    // ).submit()
    itxn_begin
    // smart_contracts/ticketing_app/contract.py:79
    // receiver=self.organizer.value,
    intc_0 // 0
    bytec_0 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/ticketing_app/contract.py:77-78
    // # Pay out ALGO to organizer
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/ticketing_app/contract.py:77-81
    // # Pay out ALGO to organizer
    // itxn.Payment(
    //     receiver=self.organizer.value,
    //     amount=amt
    // ).submit()
    itxn_submit
    // smart_contracts/ticketing_app/contract.py:68
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.ticketing_app.contract.TicketingApp.get_sale_info[routing]() -> void:
get_sale_info:
    // smart_contracts/ticketing_app/contract.py:87
    // self.asset_id.value,
    intc_0 // 0
    bytec_2 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/ticketing_app/contract.py:88
    // self.unit_price.value,
    intc_0 // 0
    bytec 4 // "unit_price"
    app_global_get_ex
    assert // check self.unit_price exists
    // smart_contracts/ticketing_app/contract.py:89
    // self.sale_start.value,
    intc_0 // 0
    bytec 5 // "sale_start"
    app_global_get_ex
    assert // check self.sale_start exists
    // smart_contracts/ticketing_app/contract.py:90
    // self.sale_end.value,
    intc_0 // 0
    bytec 6 // "sale_end"
    app_global_get_ex
    assert // check self.sale_end exists
    // smart_contracts/ticketing_app/contract.py:91
    // self.organizer.value,
    intc_0 // 0
    bytec_0 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    // smart_contracts/ticketing_app/contract.py:92
    // self.per_cap.value,
    intc_0 // 0
    bytec 7 // "per_cap"
    app_global_get_ex
    assert // check self.per_cap exists
    // smart_contracts/ticketing_app/contract.py:93
    // self.proceeds.value,
    intc_0 // 0
    bytec_1 // "proceeds"
    app_global_get_ex
    assert // check self.proceeds exists
    // smart_contracts/ticketing_app/contract.py:83
    // @abimethod
    uncover 6
    itob
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.ticketing_app.contract.TicketingApp.get_purchased[routing]() -> void:
get_purchased:
    // smart_contracts/ticketing_app/contract.py:96
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/ticketing_app/contract.py:99
    // return self.purchased[buyer]
    intc_0 // 0
    bytec 8 // "purchased"
    app_local_get_ex
    assert // check self.purchased exists for account
    // smart_contracts/ticketing_app/contract.py:96
    // @abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.ticketing_app.contract.TicketingApp.hello[routing]() -> void:
hello:
    // smart_contracts/ticketing_app/contract.py:101
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/ticketing_app/contract.py:104
    // return "Hello, " + name
    pushbytes "Hello, "
    swap
    concat
    // smart_contracts/ticketing_app/contract.py:101
    // @abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
