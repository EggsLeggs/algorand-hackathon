#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 2 8 1
    bytecblock 0x151f7c75
    // smart_contracts/ticketing_app/contract.py:5
    // class TicketingApp(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@9
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x02bece11 0xa8b55eb4 // method "hello(string)string", method "createEvent(string,string,string,uint64,uint64,string,string,string,string,string,string,string,uint64,uint64,string,uint64,uint64,address,address,string,string,uint64,string,string,uint64,uint64)uint64"
    txna ApplicationArgs 0
    match hello createEvent
    err

main___algopy_default_create@9:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.ticketing_app.contract.TicketingApp.hello[routing]() -> void:
hello:
    // smart_contracts/ticketing_app/contract.py:17
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/ticketing_app/contract.py:19
    // return "Hello, " + name
    pushbytes "Hello, "
    swap
    concat
    // smart_contracts/ticketing_app/contract.py:17
    // @abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_3 // 1
    return


// smart_contracts.ticketing_app.contract.TicketingApp.createEvent[routing]() -> void:
createEvent:
    // smart_contracts/ticketing_app/contract.py:21
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 7
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 8
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 9
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 10
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 11
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 12
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 13
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 14
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 15
    extract 18 32
    txna ApplicationArgs 15
    extract 50 32
    txna ApplicationArgs 15
    dup
    pushint 82 // 82
    extract_uint16
    dig 1
    pushint 84 // 84
    extract_uint16
    substring3
    extract 2 0
    txna ApplicationArgs 15
    dup
    pushint 84 // 84
    extract_uint16
    dig 1
    pushint 94 // 94
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/ticketing_app/contract.py:100-114
    // # Create the event ASA
    // ixtn_result = itxn.AssetConfig(
    //     total=ticket_supply,
    //     decimals=0,  # Each token represents one ticket
    //     default_frozen=False,
    //     unit_name=asa_unit_name,
    //     asset_name=asa_asset_name,
    //     manager=issuer_address,
    //     reserve=treasury_address,
    //     freeze=issuer_address,
    //     clawback=issuer_address,
    //     url=website,
    //     # metadata_hash omitted - will be None/undefined
    //     note=b"EVENT_TICKET",
    // ).submit()
    itxn_begin
    // smart_contracts/ticketing_app/contract.py:112-113
    // # metadata_hash omitted - will be None/undefined
    // note=b"EVENT_TICKET",
    pushbytes 0x4556454e545f5449434b4554
    itxn_field Note
    uncover 5
    itxn_field ConfigAssetURL
    dig 2
    itxn_field ConfigAssetClawback
    dig 2
    itxn_field ConfigAssetFreeze
    uncover 3
    itxn_field ConfigAssetReserve
    uncover 2
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetName
    itxn_field ConfigAssetUnitName
    // smart_contracts/ticketing_app/contract.py:104
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    // smart_contracts/ticketing_app/contract.py:103
    // decimals=0,  # Each token represents one ticket
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    itxn_field ConfigAssetTotal
    // smart_contracts/ticketing_app/contract.py:100-101
    // # Create the event ASA
    // ixtn_result = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/ticketing_app/contract.py:100-114
    // # Create the event ASA
    // ixtn_result = itxn.AssetConfig(
    //     total=ticket_supply,
    //     decimals=0,  # Each token represents one ticket
    //     default_frozen=False,
    //     unit_name=asa_unit_name,
    //     asset_name=asa_asset_name,
    //     manager=issuer_address,
    //     reserve=treasury_address,
    //     freeze=issuer_address,
    //     clawback=issuer_address,
    //     url=website,
    //     # metadata_hash omitted - will be None/undefined
    //     note=b"EVENT_TICKET",
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/ticketing_app/contract.py:21
    // @abimethod()
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_3 // 1
    return
